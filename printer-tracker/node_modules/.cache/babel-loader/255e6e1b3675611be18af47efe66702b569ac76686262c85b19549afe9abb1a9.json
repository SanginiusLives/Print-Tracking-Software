{"ast":null,"code":"// ../node_modules/@tldraw/vec/dist/esm/index.js\nvar _Vec = class {\n  static clamp(n, min, max) {\n    return Math.max(min, typeof max !== \"undefined\" ? Math.min(n, max) : n);\n  }\n  static clampV(A, min, max) {\n    return A.map(n => max ? _Vec.clamp(n, min, max) : _Vec.clamp(n, min));\n  }\n  static cross(x, y, z) {\n    return (y[0] - x[0]) * (z[1] - x[1]) - (z[0] - x[0]) * (y[1] - x[1]);\n  }\n  static snap(a, step = 1) {\n    return [Math.round(a[0] / step) * step, Math.round(a[1] / step) * step];\n  }\n};\nvar Vec = _Vec;\nVec.neg = A => {\n  return [-A[0], -A[1]];\n};\nVec.add = (A, B) => {\n  return [A[0] + B[0], A[1] + B[1]];\n};\nVec.addScalar = (A, n) => {\n  return [A[0] + n, A[1] + n];\n};\nVec.sub = (A, B) => {\n  return [A[0] - B[0], A[1] - B[1]];\n};\nVec.subScalar = (A, n) => {\n  return [A[0] - n, A[1] - n];\n};\nVec.vec = (A, B) => {\n  return [B[0] - A[0], B[1] - A[1]];\n};\nVec.mul = (A, n) => {\n  return [A[0] * n, A[1] * n];\n};\nVec.mulV = (A, B) => {\n  return [A[0] * B[0], A[1] * B[1]];\n};\nVec.div = (A, n) => {\n  return [A[0] / n, A[1] / n];\n};\nVec.divV = (A, B) => {\n  return [A[0] / B[0], A[1] / B[1]];\n};\nVec.per = A => {\n  return [A[1], -A[0]];\n};\nVec.dpr = (A, B) => {\n  return A[0] * B[0] + A[1] * B[1];\n};\nVec.cpr = (A, B) => {\n  return A[0] * B[1] - B[0] * A[1];\n};\nVec.len2 = A => {\n  return A[0] * A[0] + A[1] * A[1];\n};\nVec.len = A => {\n  return Math.hypot(A[0], A[1]);\n};\nVec.pry = (A, B) => {\n  return _Vec.dpr(A, B) / _Vec.len(B);\n};\nVec.uni = A => {\n  return _Vec.div(A, _Vec.len(A));\n};\nVec.normalize = A => {\n  return _Vec.uni(A);\n};\nVec.tangent = (A, B) => {\n  return _Vec.uni(_Vec.sub(A, B));\n};\nVec.dist2 = (A, B) => {\n  return _Vec.len2(_Vec.sub(A, B));\n};\nVec.dist = (A, B) => {\n  return Math.hypot(A[1] - B[1], A[0] - B[0]);\n};\nVec.fastDist = (A, B) => {\n  const V = [B[0] - A[0], B[1] - A[1]];\n  const aV = [Math.abs(V[0]), Math.abs(V[1])];\n  let r = 1 / Math.max(aV[0], aV[1]);\n  r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289);\n  return [V[0] * r, V[1] * r];\n};\nVec.ang = (A, B) => {\n  return Math.atan2(_Vec.cpr(A, B), _Vec.dpr(A, B));\n};\nVec.angle = (A, B) => {\n  return Math.atan2(B[1] - A[1], B[0] - A[0]);\n};\nVec.med = (A, B) => {\n  return _Vec.mul(_Vec.add(A, B), 0.5);\n};\nVec.rot = (A, r = 0) => {\n  return [A[0] * Math.cos(r) - A[1] * Math.sin(r), A[0] * Math.sin(r) + A[1] * Math.cos(r)];\n};\nVec.rotWith = (A, C, r = 0) => {\n  if (r === 0) return A;\n  const s = Math.sin(r);\n  const c = Math.cos(r);\n  const px = A[0] - C[0];\n  const py = A[1] - C[1];\n  const nx = px * c - py * s;\n  const ny = px * s + py * c;\n  return [nx + C[0], ny + C[1]];\n};\nVec.isEqual = (A, B) => {\n  return A[0] === B[0] && A[1] === B[1];\n};\nVec.lrp = (A, B, t) => {\n  return _Vec.add(A, _Vec.mul(_Vec.sub(B, A), t));\n};\nVec.int = (A, B, from, to, s = 1) => {\n  const t = (_Vec.clamp(from, to) - from) / (to - from);\n  return _Vec.add(_Vec.mul(A, 1 - t), _Vec.mul(B, s));\n};\nVec.ang3 = (p1, pc, p2) => {\n  const v1 = _Vec.vec(pc, p1);\n  const v2 = _Vec.vec(pc, p2);\n  return _Vec.ang(v1, v2);\n};\nVec.abs = A => {\n  return [Math.abs(A[0]), Math.abs(A[1])];\n};\nVec.rescale = (a, n) => {\n  const l = _Vec.len(a);\n  return [n * a[0] / l, n * a[1] / l];\n};\nVec.isLeft = (p1, pc, p2) => {\n  return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1]);\n};\nVec.clockwise = (p1, pc, p2) => {\n  return _Vec.isLeft(p1, pc, p2) > 0;\n};\nVec.toFixed = (a, d = 2) => {\n  return a.map(v => +v.toFixed(d));\n};\nVec.nearestPointOnLineThroughPoint = (A, u, P) => {\n  return _Vec.add(A, _Vec.mul(u, _Vec.pry(_Vec.sub(P, A), u)));\n};\nVec.distanceToLineThroughPoint = (A, u, P) => {\n  return _Vec.dist(P, _Vec.nearestPointOnLineThroughPoint(A, u, P));\n};\nVec.nearestPointOnLineSegment = (A, B, P, clamp = true) => {\n  const u = _Vec.uni(_Vec.sub(B, A));\n  const C = _Vec.add(A, _Vec.mul(u, _Vec.pry(_Vec.sub(P, A), u)));\n  if (clamp) {\n    if (C[0] < Math.min(A[0], B[0])) return A[0] < B[0] ? A : B;\n    if (C[0] > Math.max(A[0], B[0])) return A[0] > B[0] ? A : B;\n    if (C[1] < Math.min(A[1], B[1])) return A[1] < B[1] ? A : B;\n    if (C[1] > Math.max(A[1], B[1])) return A[1] > B[1] ? A : B;\n  }\n  return C;\n};\nVec.distanceToLineSegment = (A, B, P, clamp = true) => {\n  return _Vec.dist(P, _Vec.nearestPointOnLineSegment(A, B, P, clamp));\n};\nVec.nudge = (A, B, d) => {\n  if (_Vec.isEqual(A, B)) return A;\n  return _Vec.add(A, _Vec.mul(_Vec.uni(_Vec.sub(B, A)), d));\n};\nVec.nudgeAtAngle = (A, a, d) => {\n  return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]];\n};\nVec.toPrecision = (a, n = 4) => {\n  return [+a[0].toPrecision(n), +a[1].toPrecision(n)];\n};\nVec.pointsBetween = (A, B, steps = 6) => {\n  return Array.from(Array(steps)).map((_, i) => {\n    const t = i / (steps - 1);\n    const k = Math.min(1, 0.5 + Math.abs(0.5 - t));\n    return [..._Vec.lrp(A, B, t), k];\n  });\n};\nVec.slope = (A, B) => {\n  if (A[0] === B[0]) return NaN;\n  return (A[1] - B[1]) / (A[0] - B[0]);\n};\nVec.max = (...v) => {\n  return [Math.max(...v.map(a => a[0])), Math.max(...v.map(a => a[1]))];\n};\nVec.min = (...v) => {\n  return [Math.max(...v.map(a => a[0])), Math.max(...v.map(a => a[1]))];\n};\n\n// src/spline.ts\nvar Spline = class {\n  constructor(points = []) {\n    this.points = [];\n    this.lengths = [];\n    this.totalLength = 0;\n    this.addPoint = point => {\n      if (this.prev) {\n        const length = Vec.dist(this.prev, point);\n        this.lengths.push(length);\n        this.totalLength += length;\n        this.points.push(point);\n      }\n      this.prev = point;\n    };\n    this.clear = () => {\n      this.points = this.prev ? [this.prev] : [];\n      this.totalLength = 0;\n    };\n    this.getSplinePoint = rt => {\n      const {\n        points\n      } = this;\n      const l = points.length - 1,\n        d = Math.trunc(rt),\n        p1 = Math.min(d + 1, l),\n        p2 = Math.min(p1 + 1, l),\n        p3 = Math.min(p2 + 1, l),\n        p0 = p1 - 1,\n        t = rt - d;\n      const tt = t * t,\n        ttt = tt * t,\n        q1 = -ttt + 2 * tt - t,\n        q2 = 3 * ttt - 5 * tt + 2,\n        q3 = -3 * ttt + 4 * tt + t,\n        q4 = ttt - tt;\n      return [(points[p0][0] * q1 + points[p1][0] * q2 + points[p2][0] * q3 + points[p3][0] * q4) / 2, (points[p0][1] * q1 + points[p1][1] * q2 + points[p2][1] * q3 + points[p3][1] * q4) / 2];\n    };\n    this.points = points;\n    this.lengths = points.map((point, i, arr) => i === 0 ? 0 : Vec.dist(point, arr[i - 1]));\n    this.totalLength = this.lengths.reduce((acc, cur) => acc + cur, 0);\n  }\n};\n\n// src/perfect-cursor.ts\nvar _PerfectCursor = class {\n  constructor(cb) {\n    this.state = \"idle\";\n    this.queue = [];\n    this.timestamp = performance.now();\n    this.lastRequestId = 0;\n    this.timeoutId = 0;\n    this.spline = new Spline();\n    this.addPoint = point => {\n      clearTimeout(this.timeoutId);\n      const now = performance.now();\n      const duration = Math.min(now - this.timestamp, _PerfectCursor.MAX_INTERVAL);\n      if (!this.prevPoint) {\n        this.spline.clear();\n        this.prevPoint = point;\n        this.spline.addPoint(point);\n        this.cb(point);\n        this.state = \"stopped\";\n        return;\n      }\n      if (this.state === \"stopped\") {\n        if (Vec.dist(this.prevPoint, point) < 4) {\n          this.cb(point);\n          return;\n        }\n        this.spline.clear();\n        this.spline.addPoint(this.prevPoint);\n        this.spline.addPoint(this.prevPoint);\n        this.spline.addPoint(point);\n        this.state = \"idle\";\n      } else {\n        this.spline.addPoint(point);\n      }\n      if (duration < 16) {\n        this.prevPoint = point;\n        this.timestamp = now;\n        this.cb(point);\n        return;\n      }\n      const animation = {\n        start: this.spline.points.length - 3,\n        from: this.prevPoint,\n        to: point,\n        duration\n      };\n      this.prevPoint = point;\n      this.timestamp = now;\n      switch (this.state) {\n        case \"idle\":\n          {\n            this.state = \"animating\";\n            this.animateNext(animation);\n            break;\n          }\n        case \"animating\":\n          {\n            this.queue.push(animation);\n            break;\n          }\n      }\n    };\n    this.animateNext = animation => {\n      const start = performance.now();\n      const loop = () => {\n        const t = (performance.now() - start) / animation.duration;\n        if (t <= 1 && this.spline.points.length > 0) {\n          try {\n            this.cb(this.spline.getSplinePoint(t + animation.start));\n          } catch (e) {\n            console.warn(e);\n          }\n          this.lastRequestId = requestAnimationFrame(loop);\n          return;\n        }\n        const next = this.queue.shift();\n        if (next) {\n          this.state = \"animating\";\n          this.animateNext(next);\n        } else {\n          this.state = \"idle\";\n          this.timeoutId = setTimeout(() => {\n            this.state = \"stopped\";\n          }, _PerfectCursor.MAX_INTERVAL);\n        }\n      };\n      loop();\n    };\n    this.dispose = () => {\n      clearTimeout(this.timeoutId);\n    };\n    this.cb = cb;\n  }\n};\nvar PerfectCursor = _PerfectCursor;\nPerfectCursor.MAX_INTERVAL = 300;\nexport { PerfectCursor };","map":{"version":3,"names":["_Vec","clamp","n","min","max","Math","clampV","A","map","cross","x","y","z","snap","a","step","round","Vec","neg","add","B","addScalar","sub","subScalar","vec","mul","mulV","div","divV","per","dpr","cpr","len2","len","hypot","pry","uni","normalize","tangent","dist2","dist","fastDist","V","aV","abs","r","ang","atan2","angle","med","rot","cos","sin","rotWith","C","s","c","px","py","nx","ny","isEqual","lrp","t","int","from","to","ang3","p1","pc","p2","v1","v2","rescale","l","isLeft","clockwise","toFixed","d","v","nearestPointOnLineThroughPoint","u","P","distanceToLineThroughPoint","nearestPointOnLineSegment","distanceToLineSegment","nudge","nudgeAtAngle","toPrecision","pointsBetween","steps","Array","_","i","k","slope","NaN","Spline","constructor","points","lengths","totalLength","addPoint","point","prev","length","push","clear","getSplinePoint","rt","trunc","p3","p0","tt","ttt","q1","q2","q3","q4","arr","reduce","acc","cur","_PerfectCursor","cb","state","queue","timestamp","performance","now","lastRequestId","timeoutId","spline","clearTimeout","duration","MAX_INTERVAL","prevPoint","animation","start","animateNext","loop","e","console","warn","requestAnimationFrame","next","shift","setTimeout","dispose","PerfectCursor"],"sources":["/home/lauder/Full-Print-Track/printer-tracker/node_modules/node_modules/@tldraw/vec/src/index.ts","/home/lauder/Full-Print-Track/printer-tracker/node_modules/perfect-cursors/src/spline.ts","/home/lauder/Full-Print-Track/printer-tracker/node_modules/perfect-cursors/src/perfect-cursor.ts"],"sourcesContent":["export class Vec {\n  /**\n   * Clamp a value into a range.\n   * @param n\n   * @param min\n   */\n  static clamp(n: number, min: number): number\n  static clamp(n: number, min: number, max: number): number\n  static clamp(n: number, min: number, max?: number): number {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)\n  }\n\n  /**\n   * Clamp a value into a range.\n   * @param n\n   * @param min\n   */\n  static clampV(A: number[], min: number): number[]\n  static clampV(A: number[], min: number, max: number): number[]\n  static clampV(A: number[], min: number, max?: number): number[] {\n    return A.map((n) => (max ? Vec.clamp(n, min, max) : Vec.clamp(n, min)))\n  }\n\n  /**\n   * Negate a vector.\n   * @param A\n   */\n  static neg = (A: number[]): number[] => {\n    return [-A[0], -A[1]]\n  }\n\n  /**\n   * Add vectors.\n   * @param A\n   * @param B\n   */\n  static add = (A: number[], B: number[]): number[] => {\n    return [A[0] + B[0], A[1] + B[1]]\n  }\n\n  /**\n   * Add scalar to vector.\n   * @param A\n   * @param B\n   */\n  static addScalar = (A: number[], n: number): number[] => {\n    return [A[0] + n, A[1] + n]\n  }\n\n  /**\n   * Subtract vectors.\n   * @param A\n   * @param B\n   */\n  static sub = (A: number[], B: number[]): number[] => {\n    return [A[0] - B[0], A[1] - B[1]]\n  }\n\n  /**\n   * Subtract scalar from vector.\n   * @param A\n   * @param B\n   */\n  static subScalar = (A: number[], n: number): number[] => {\n    return [A[0] - n, A[1] - n]\n  }\n\n  /**\n   * Get the vector from vectors A to B.\n   * @param A\n   * @param B\n   */\n  static vec = (A: number[], B: number[]): number[] => {\n    // A, B as vectors get the vector from A to B\n    return [B[0] - A[0], B[1] - A[1]]\n  }\n\n  /**\n   * Vector multiplication by scalar\n   * @param A\n   * @param n\n   */\n  static mul = (A: number[], n: number): number[] => {\n    return [A[0] * n, A[1] * n]\n  }\n\n  /**\n   * Multiple two vectors.\n   * @param A\n   * @param B\n   */\n  static mulV = (A: number[], B: number[]): number[] => {\n    return [A[0] * B[0], A[1] * B[1]]\n  }\n\n  /**\n   * Vector division by scalar.\n   * @param A\n   * @param n\n   */\n  static div = (A: number[], n: number): number[] => {\n    return [A[0] / n, A[1] / n]\n  }\n\n  /**\n   * Vector division by vector.\n   * @param A\n   * @param n\n   */\n  static divV = (A: number[], B: number[]): number[] => {\n    return [A[0] / B[0], A[1] / B[1]]\n  }\n\n  /**\n   * Perpendicular rotation of a vector A\n   * @param A\n   */\n  static per = (A: number[]): number[] => {\n    return [A[1], -A[0]]\n  }\n\n  /**\n   * Dot product\n   * @param A\n   * @param B\n   */\n  static dpr = (A: number[], B: number[]): number => {\n    return A[0] * B[0] + A[1] * B[1]\n  }\n\n  /**\n   * Cross product (outer product) | A X B |\n   * @param A\n   * @param B\n   */\n  static cpr = (A: number[], B: number[]): number => {\n    return A[0] * B[1] - B[0] * A[1]\n  }\n\n  /**\n   * Cross (for point in polygon)\n   *\n   */\n  static cross(x: number[], y: number[], z: number[]): number {\n    return (y[0] - x[0]) * (z[1] - x[1]) - (z[0] - x[0]) * (y[1] - x[1])\n  }\n\n  /**\n   * Length of the vector squared\n   * @param A\n   */\n  static len2 = (A: number[]): number => {\n    return A[0] * A[0] + A[1] * A[1]\n  }\n\n  /**\n   * Length of the vector\n   * @param A\n   */\n  static len = (A: number[]): number => {\n    return Math.hypot(A[0], A[1])\n  }\n\n  /**\n   * Project A over B\n   * @param A\n   * @param B\n   */\n  static pry = (A: number[], B: number[]): number => {\n    return Vec.dpr(A, B) / Vec.len(B)\n  }\n\n  /**\n   * Get normalized / unit vector.\n   * @param A\n   */\n  static uni = (A: number[]): number[] => {\n    return Vec.div(A, Vec.len(A))\n  }\n\n  /**\n   * Get normalized / unit vector.\n   * @param A\n   */\n  static normalize = (A: number[]): number[] => {\n    return Vec.uni(A)\n  }\n\n  /**\n   * Get the tangent between two vectors.\n   * @param A\n   * @param B\n   * @returns\n   */\n  static tangent = (A: number[], B: number[]): number[] => {\n    return Vec.uni(Vec.sub(A, B))\n  }\n\n  /**\n   * Dist length from A to B squared.\n   * @param A\n   * @param B\n   */\n  static dist2 = (A: number[], B: number[]): number => {\n    return Vec.len2(Vec.sub(A, B))\n  }\n\n  /**\n   * Dist length from A to B\n   * @param A\n   * @param B\n   */\n  static dist = (A: number[], B: number[]): number => {\n    return Math.hypot(A[1] - B[1], A[0] - B[0])\n  }\n\n  /**\n   * A faster, though less accurate method for testing distances. Maybe faster?\n   * @param A\n   * @param B\n   * @returns\n   */\n  static fastDist = (A: number[], B: number[]): number[] => {\n    const V = [B[0] - A[0], B[1] - A[1]]\n    const aV = [Math.abs(V[0]), Math.abs(V[1])]\n    let r = 1 / Math.max(aV[0], aV[1])\n    r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289)\n    return [V[0] * r, V[1] * r]\n  }\n\n  /**\n   * Angle between vector A and vector B in radians\n   * @param A\n   * @param B\n   */\n  static ang = (A: number[], B: number[]): number => {\n    return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B))\n  }\n\n  /**\n   * Angle between vector A and vector B in radians\n   * @param A\n   * @param B\n   */\n  static angle = (A: number[], B: number[]): number => {\n    return Math.atan2(B[1] - A[1], B[0] - A[0])\n  }\n\n  /**\n   * Mean between two vectors or mid vector between two vectors\n   * @param A\n   * @param B\n   */\n  static med = (A: number[], B: number[]): number[] => {\n    return Vec.mul(Vec.add(A, B), 0.5)\n  }\n\n  /**\n   * Vector rotation by r (radians)\n   * @param A\n   * @param r rotation in radians\n   */\n  static rot = (A: number[], r = 0): number[] => {\n    return [A[0] * Math.cos(r) - A[1] * Math.sin(r), A[0] * Math.sin(r) + A[1] * Math.cos(r)]\n  }\n\n  /**\n   * Rotate a vector around another vector by r (radians)\n   * @param A vector\n   * @param C center\n   * @param r rotation in radians\n   */\n  static rotWith = (A: number[], C: number[], r = 0): number[] => {\n    if (r === 0) return A\n\n    const s = Math.sin(r)\n    const c = Math.cos(r)\n\n    const px = A[0] - C[0]\n    const py = A[1] - C[1]\n\n    const nx = px * c - py * s\n    const ny = px * s + py * c\n\n    return [nx + C[0], ny + C[1]]\n  }\n\n  /**\n   * Check of two vectors are identical.\n   * @param A\n   * @param B\n   */\n  static isEqual = (A: number[], B: number[]): boolean => {\n    return A[0] === B[0] && A[1] === B[1]\n  }\n\n  /**\n   * Interpolate vector A to B with a scalar t\n   * @param A\n   * @param B\n   * @param t scalar\n   */\n  static lrp = (A: number[], B: number[], t: number): number[] => {\n    return Vec.add(A, Vec.mul(Vec.sub(B, A), t))\n  }\n\n  /**\n   * Interpolate from A to B when curVAL goes fromVAL: number[] => to\n   * @param A\n   * @param B\n   * @param from Starting value\n   * @param to Ending value\n   * @param s Strength\n   */\n  static int = (A: number[], B: number[], from: number, to: number, s = 1): number[] => {\n    const t = (Vec.clamp(from, to) - from) / (to - from)\n    return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s))\n  }\n\n  /**\n   * Get the angle between the three vectors A, B, and C.\n   * @param p1\n   * @param pc\n   * @param p2\n   */\n  static ang3 = (p1: number[], pc: number[], p2: number[]): number => {\n    // this,\n    const v1 = Vec.vec(pc, p1)\n    const v2 = Vec.vec(pc, p2)\n    return Vec.ang(v1, v2)\n  }\n\n  /**\n   * Absolute value of a vector.\n   * @param A\n   * @returns\n   */\n  static abs = (A: number[]): number[] => {\n    return [Math.abs(A[0]), Math.abs(A[1])]\n  }\n\n  static rescale = (a: number[], n: number): number[] => {\n    const l = Vec.len(a)\n    return [(n * a[0]) / l, (n * a[1]) / l]\n  }\n\n  /**\n   * Get whether p1 is left of p2, relative to pc.\n   * @param p1\n   * @param pc\n   * @param p2\n   */\n  static isLeft = (p1: number[], pc: number[], p2: number[]): number => {\n    //  isLeft: >0 for counterclockwise\n    //          =0 for none (degenerate)\n    //          <0 for clockwise\n    return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1])\n  }\n\n  /**\n   * Get whether p1 is left of p2, relative to pc.\n   * @param p1\n   * @param pc\n   * @param p2\n   */\n  static clockwise = (p1: number[], pc: number[], p2: number[]): boolean => {\n    return Vec.isLeft(p1, pc, p2) > 0\n  }\n\n  /**\n   * Round a vector to the a given precision.\n   * @param a\n   * @param d\n   */\n  static toFixed = (a: number[], d = 2): number[] => {\n    return a.map((v) => +v.toFixed(d))\n  }\n\n  /**\n   * Snap vector to nearest step.\n   * @param A\n   * @param step\n   * @example\n   * ```ts\n   * Vec.snap([10.5, 28], 10) // [10, 30]\n   * ```\n   */\n  static snap(a: number[], step = 1) {\n    return [Math.round(a[0] / step) * step, Math.round(a[1] / step) * step]\n  }\n\n  /**\n   * Get the nearest point on a line with a known unit vector that passes through point A\n   * @param A Any point on the line\n   * @param u The unit vector for the line.\n   * @param P A point not on the line to test.\n   * @returns\n   */\n  static nearestPointOnLineThroughPoint = (A: number[], u: number[], P: number[]): number[] => {\n    return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))\n  }\n\n  /**\n   * Distance between a point and a line with a known unit vector that passes through a point.\n   * @param A Any point on the line\n   * @param u The unit vector for the line.\n   * @param P A point not on the line to test.\n   * @returns\n   */\n  static distanceToLineThroughPoint = (A: number[], u: number[], P: number[]): number => {\n    return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P))\n  }\n\n  /**\n   * Get the nearest point on a line segment between A and B\n   * @param A The start of the line segment\n   * @param B The end of the line segment\n   * @param P The off-line point\n   * @param clamp Whether to clamp the point between A and B.\n   * @returns\n   */\n  static nearestPointOnLineSegment = (\n    A: number[],\n    B: number[],\n    P: number[],\n    clamp = true\n  ): number[] => {\n    const u = Vec.uni(Vec.sub(B, A))\n    const C = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))\n\n    if (clamp) {\n      if (C[0] < Math.min(A[0], B[0])) return A[0] < B[0] ? A : B\n      if (C[0] > Math.max(A[0], B[0])) return A[0] > B[0] ? A : B\n      if (C[1] < Math.min(A[1], B[1])) return A[1] < B[1] ? A : B\n      if (C[1] > Math.max(A[1], B[1])) return A[1] > B[1] ? A : B\n    }\n\n    return C\n  }\n\n  /**\n   * Distance between a point and the nearest point on a line segment between A and B\n   * @param A The start of the line segment\n   * @param B The end of the line segment\n   * @param P The off-line point\n   * @param clamp Whether to clamp the point between A and B.\n   * @returns\n   */\n  static distanceToLineSegment = (A: number[], B: number[], P: number[], clamp = true): number => {\n    return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp))\n  }\n\n  /**\n   * Push a point A towards point B by a given distance.\n   * @param A\n   * @param B\n   * @param d\n   * @returns\n   */\n  static nudge = (A: number[], B: number[], d: number): number[] => {\n    if (Vec.isEqual(A, B)) return A\n    return Vec.add(A, Vec.mul(Vec.uni(Vec.sub(B, A)), d))\n  }\n\n  /**\n   * Push a point in a given angle by a given distance.\n   * @param A\n   * @param B\n   * @param d\n   */\n  static nudgeAtAngle = (A: number[], a: number, d: number): number[] => {\n    return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]]\n  }\n\n  /**\n   * Round a vector to a precision length.\n   * @param a\n   * @param n\n   */\n  static toPrecision = (a: number[], n = 4): number[] => {\n    return [+a[0].toPrecision(n), +a[1].toPrecision(n)]\n  }\n\n  /**\n   * Get an array of points (with simulated pressure) between two points.\n   * @param A The first point.\n   * @param B The second point.\n   * @param steps The number of points to return.\n   */\n  static pointsBetween = (A: number[], B: number[], steps = 6): number[][] => {\n    return Array.from(Array(steps)).map((_, i) => {\n      const t = i / (steps - 1)\n      const k = Math.min(1, 0.5 + Math.abs(0.5 - t))\n      return [...Vec.lrp(A, B, t), k]\n    })\n  }\n\n  /**\n   * Get the slope between two points.\n   * @param A\n   * @param B\n   */\n  static slope = (A: number[], B: number[]) => {\n    if (A[0] === B[0]) return NaN\n    return (A[1] - B[1]) / (A[0] - B[0])\n  }\n\n  /**\n   * Get a vector comprised of the maximum of two or more vectors.\n   */\n  static max = (...v: number[][]) => {\n    return [Math.max(...v.map((a) => a[0])), Math.max(...v.map((a) => a[1]))]\n  }\n\n  /**\n   * Get a vector comprised of the minimum of two or more vectors.\n   */\n  static min = (...v: number[][]) => {\n    return [Math.max(...v.map((a) => a[0])), Math.max(...v.map((a) => a[1]))]\n  }\n}\n\nexport default Vec\n","import { Vec } from '@tldraw/vec'\n\nexport class Spline {\n  points: number[][] = []\n\n  lengths: number[] = []\n\n  totalLength = 0\n\n  private prev?: number[]\n\n  constructor(points: number[][] = []) {\n    this.points = points\n    this.lengths = points.map((point, i, arr) => (i === 0 ? 0 : Vec.dist(point, arr[i - 1])))\n    this.totalLength = this.lengths.reduce((acc, cur) => acc + cur, 0)\n  }\n\n  addPoint = (point: number[]) => {\n    if (this.prev) {\n      const length = Vec.dist(this.prev, point)\n      this.lengths.push(length)\n      this.totalLength += length\n      this.points.push(point)\n    }\n    this.prev = point\n  }\n\n  clear = () => {\n    this.points = this.prev ? [this.prev] : []\n    this.totalLength = 0\n  }\n\n  getSplinePoint = (rt: number): number[] => {\n    const { points } = this\n    const l = points.length - 1,\n      d = Math.trunc(rt),\n      p1 = Math.min(d + 1, l),\n      p2 = Math.min(p1 + 1, l),\n      p3 = Math.min(p2 + 1, l),\n      p0 = p1 - 1,\n      t = rt - d\n    const tt = t * t,\n      ttt = tt * t,\n      q1 = -ttt + 2 * tt - t,\n      q2 = 3 * ttt - 5 * tt + 2,\n      q3 = -3 * ttt + 4 * tt + t,\n      q4 = ttt - tt\n    return [\n      (points[p0][0] * q1 + points[p1][0] * q2 + points[p2][0] * q3 + points[p3][0] * q4) / 2,\n      (points[p0][1] * q1 + points[p1][1] * q2 + points[p2][1] * q3 + points[p3][1] * q4) / 2,\n    ]\n  }\n}\n","import { Vec } from '@tldraw/vec'\nimport { Spline } from './spline'\n\ntype AnimationState = 'stopped' | 'idle' | 'animating'\n\ntype Animation = {\n  from: number[]\n  to: number[]\n  start: number\n  duration: number\n}\n\nexport class PerfectCursor {\n  state: AnimationState = 'idle'\n  queue: Animation[] = []\n  timestamp = performance.now()\n  lastRequestId = 0\n  timeoutId: any = 0\n  prevPoint?: number[]\n  spline = new Spline()\n  cb: (point: number[]) => void\n\n  constructor(cb: (point: number[]) => void) {\n    this.cb = cb\n  }\n\n  addPoint = (point: number[]) => {\n    clearTimeout(this.timeoutId)\n    const now = performance.now()\n    const duration = Math.min(now - this.timestamp, PerfectCursor.MAX_INTERVAL)\n    if (!this.prevPoint) {\n      this.spline.clear()\n      this.prevPoint = point\n      this.spline.addPoint(point)\n      this.cb(point)\n      this.state = 'stopped'\n      return\n    }\n    if (this.state === 'stopped') {\n      if (Vec.dist(this.prevPoint, point) < 4) {\n        this.cb(point)\n        return\n      }\n      this.spline.clear()\n      this.spline.addPoint(this.prevPoint)\n      this.spline.addPoint(this.prevPoint)\n      this.spline.addPoint(point)\n      this.state = 'idle'\n    } else {\n      this.spline.addPoint(point)\n    }\n    if (duration < 16) {\n      this.prevPoint = point\n      this.timestamp = now\n      this.cb(point)\n      return\n    }\n    const animation: Animation = {\n      start: this.spline.points.length - 3,\n      from: this.prevPoint,\n      to: point,\n      duration,\n    }\n    this.prevPoint = point\n    this.timestamp = now\n    switch (this.state) {\n      case 'idle': {\n        this.state = 'animating'\n        this.animateNext(animation)\n        break\n      }\n      case 'animating': {\n        this.queue.push(animation)\n        break\n      }\n    }\n  }\n\n  animateNext = (animation: Animation) => {\n    const start = performance.now()\n    const loop = () => {\n      const t = (performance.now() - start) / animation.duration\n      if (t <= 1 && this.spline.points.length > 0) {\n        try {\n          this.cb(this.spline.getSplinePoint(t + animation.start))\n        } catch (e) {\n          console.warn(e)\n        }\n        this.lastRequestId = requestAnimationFrame(loop)\n        return\n      }\n      const next = this.queue.shift()\n      if (next) {\n        this.state = 'animating'\n        this.animateNext(next)\n      } else {\n        this.state = 'idle'\n        this.timeoutId = setTimeout(() => {\n          this.state = 'stopped'\n        }, PerfectCursor.MAX_INTERVAL)\n      }\n    }\n    loop()\n  }\n\n  static MAX_INTERVAL = 300\n\n  dispose = () => {\n    clearTimeout(this.timeoutId)\n  }\n}\n"],"mappings":";AAAO,IAAAA,IAAA,SAAU;SAQRC,MAAMC,CAAA,EAAWC,GAAA,EAAaC,GAAA,EAAsB;IACzD,OAAOC,IAAA,CAAKD,GAAA,CAAID,GAAA,EAAK,OAAOC,GAAA,KAAQ,cAAcC,IAAA,CAAKF,GAAA,CAAID,CAAA,EAAGE,GAAA,IAAOF,CAAA;;SAUhEI,OAAOC,CAAA,EAAaJ,GAAA,EAAaC,GAAA,EAAwB;IAC9D,OAAOG,CAAA,CAAEC,GAAA,CAAKN,CAAA,IAAOE,GAAA,GAAMJ,IAAA,CAAIC,KAAA,CAAMC,CAAA,EAAGC,GAAA,EAAKC,GAAA,IAAOJ,IAAA,CAAIC,KAAA,CAAMC,CAAA,EAAGC,GAAA;;SA2H5DM,MAAMC,CAAA,EAAaC,CAAA,EAAaC,CAAA,EAAqB;IAC1D,OAAQ,CAAAD,CAAA,CAAE,KAAKD,CAAA,CAAE,OAAOE,CAAA,CAAE,KAAKF,CAAA,CAAE,MAAO,CAAAE,CAAA,CAAE,KAAKF,CAAA,CAAE,OAAOC,CAAA,CAAE,KAAKD,CAAA,CAAE;;SAmP5DG,KAAKC,CAAA,EAAaC,IAAA,GAAO,GAAG;IACjC,OAAO,CAACV,IAAA,CAAKW,KAAA,CAAMF,CAAA,CAAE,KAAKC,IAAA,IAAQA,IAAA,EAAMV,IAAA,CAAKW,KAAA,CAAMF,CAAA,CAAE,KAAKC,IAAA,IAAQA,IAAA;;;AApY/D,IAAAE,GAAA,GAAAjB,IAAA;AAAAiB,GAAA,CA2BEC,GAAA,GAAOX,CAAA,IAA0B;EACtC,OAAO,CAAC,CAACA,CAAA,CAAE,IAAI,CAACA,CAAA,CAAE;;AA5BfU,GAAA,CAoCEE,GAAA,GAAM,CAACZ,CAAA,EAAaa,CAAA,KAA0B;EACnD,OAAO,CAACb,CAAA,CAAE,KAAKa,CAAA,CAAE,IAAIb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AArC3BH,GAAA,CA6CEI,SAAA,GAAY,CAACd,CAAA,EAAaL,CAAA,KAAwB;EACvD,OAAO,CAACK,CAAA,CAAE,KAAKL,CAAA,EAAGK,CAAA,CAAE,KAAKL,CAAA;;AA9CtBe,GAAA,CAsDEK,GAAA,GAAM,CAACf,CAAA,EAAaa,CAAA,KAA0B;EACnD,OAAO,CAACb,CAAA,CAAE,KAAKa,CAAA,CAAE,IAAIb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AAvD3BH,GAAA,CA+DEM,SAAA,GAAY,CAAChB,CAAA,EAAaL,CAAA,KAAwB;EACvD,OAAO,CAACK,CAAA,CAAE,KAAKL,CAAA,EAAGK,CAAA,CAAE,KAAKL,CAAA;;AAhEtBe,GAAA,CAwEEO,GAAA,GAAM,CAACjB,CAAA,EAAaa,CAAA,KAA0B;EAEnD,OAAO,CAACA,CAAA,CAAE,KAAKb,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAKb,CAAA,CAAE;;AA1E3BU,GAAA,CAkFEQ,GAAA,GAAM,CAAClB,CAAA,EAAaL,CAAA,KAAwB;EACjD,OAAO,CAACK,CAAA,CAAE,KAAKL,CAAA,EAAGK,CAAA,CAAE,KAAKL,CAAA;;AAnFtBe,GAAA,CA2FES,IAAA,GAAO,CAACnB,CAAA,EAAaa,CAAA,KAA0B;EACpD,OAAO,CAACb,CAAA,CAAE,KAAKa,CAAA,CAAE,IAAIb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AA5F3BH,GAAA,CAoGEU,GAAA,GAAM,CAACpB,CAAA,EAAaL,CAAA,KAAwB;EACjD,OAAO,CAACK,CAAA,CAAE,KAAKL,CAAA,EAAGK,CAAA,CAAE,KAAKL,CAAA;;AArGtBe,GAAA,CA6GEW,IAAA,GAAO,CAACrB,CAAA,EAAaa,CAAA,KAA0B;EACpD,OAAO,CAACb,CAAA,CAAE,KAAKa,CAAA,CAAE,IAAIb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AA9G3BH,GAAA,CAqHEY,GAAA,GAAOtB,CAAA,IAA0B;EACtC,OAAO,CAACA,CAAA,CAAE,IAAI,CAACA,CAAA,CAAE;;AAtHdU,GAAA,CA8HEa,GAAA,GAAM,CAACvB,CAAA,EAAaa,CAAA,KAAwB;EACjD,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE,KAAKb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AA/H3BH,GAAA,CAuIEc,GAAA,GAAM,CAACxB,CAAA,EAAaa,CAAA,KAAwB;EACjD,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE,KAAKA,CAAA,CAAE,KAAKb,CAAA,CAAE;;AAxI3BU,GAAA,CAuJEe,IAAA,GAAQzB,CAAA,IAAwB;EACrC,OAAOA,CAAA,CAAE,KAAKA,CAAA,CAAE,KAAKA,CAAA,CAAE,KAAKA,CAAA,CAAE;;AAxJ3BU,GAAA,CA+JEgB,GAAA,GAAO1B,CAAA,IAAwB;EACpC,OAAOF,IAAA,CAAK6B,KAAA,CAAM3B,CAAA,CAAE,IAAIA,CAAA,CAAE;;AAhKvBU,GAAA,CAwKEkB,GAAA,GAAM,CAAC5B,CAAA,EAAaa,CAAA,KAAwB;EACjD,OAAOpB,IAAA,CAAI8B,GAAA,CAAIvB,CAAA,EAAGa,CAAA,IAAKpB,IAAA,CAAIiC,GAAA,CAAIb,CAAA;;AAzK5BH,GAAA,CAgLEmB,GAAA,GAAO7B,CAAA,IAA0B;EACtC,OAAOP,IAAA,CAAI2B,GAAA,CAAIpB,CAAA,EAAGP,IAAA,CAAIiC,GAAA,CAAI1B,CAAA;;AAjLvBU,GAAA,CAwLEoB,SAAA,GAAa9B,CAAA,IAA0B;EAC5C,OAAOP,IAAA,CAAIoC,GAAA,CAAI7B,CAAA;;AAzLZU,GAAA,CAkMEqB,OAAA,GAAU,CAAC/B,CAAA,EAAaa,CAAA,KAA0B;EACvD,OAAOpB,IAAA,CAAIoC,GAAA,CAAIpC,IAAA,CAAIsB,GAAA,CAAIf,CAAA,EAAGa,CAAA;;AAnMvBH,GAAA,CA2MEsB,KAAA,GAAQ,CAAChC,CAAA,EAAaa,CAAA,KAAwB;EACnD,OAAOpB,IAAA,CAAIgC,IAAA,CAAKhC,IAAA,CAAIsB,GAAA,CAAIf,CAAA,EAAGa,CAAA;;AA5MxBH,GAAA,CAoNEuB,IAAA,GAAO,CAACjC,CAAA,EAAaa,CAAA,KAAwB;EAClD,OAAOf,IAAA,CAAK6B,KAAA,CAAM3B,CAAA,CAAE,KAAKa,CAAA,CAAE,IAAIb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AArNrCH,GAAA,CA8NEwB,QAAA,GAAW,CAAClC,CAAA,EAAaa,CAAA,KAA0B;EACxD,MAAMsB,CAAA,GAAI,CAACtB,CAAA,CAAE,KAAKb,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAKb,CAAA,CAAE;EACjC,MAAMoC,EAAA,GAAK,CAACtC,IAAA,CAAKuC,GAAA,CAAIF,CAAA,CAAE,KAAKrC,IAAA,CAAKuC,GAAA,CAAIF,CAAA,CAAE;EACvC,IAAIG,CAAA,GAAI,IAAIxC,IAAA,CAAKD,GAAA,CAAIuC,EAAA,CAAG,IAAIA,EAAA,CAAG;EAC/BE,CAAA,GAAIA,CAAA,IAAK,UAAW,CAAAF,EAAA,CAAG,KAAKA,EAAA,CAAG,MAAME,CAAA,GAAI;EACzC,OAAO,CAACH,CAAA,CAAE,KAAKG,CAAA,EAAGH,CAAA,CAAE,KAAKG,CAAA;;AAnOtB5B,GAAA,CA2OE6B,GAAA,GAAM,CAACvC,CAAA,EAAaa,CAAA,KAAwB;EACjD,OAAOf,IAAA,CAAK0C,KAAA,CAAM/C,IAAA,CAAI+B,GAAA,CAAIxB,CAAA,EAAGa,CAAA,GAAIpB,IAAA,CAAI8B,GAAA,CAAIvB,CAAA,EAAGa,CAAA;;AA5OzCH,GAAA,CAoPE+B,KAAA,GAAQ,CAACzC,CAAA,EAAaa,CAAA,KAAwB;EACnD,OAAOf,IAAA,CAAK0C,KAAA,CAAM3B,CAAA,CAAE,KAAKb,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAKb,CAAA,CAAE;;AArPrCU,GAAA,CA6PEgC,GAAA,GAAM,CAAC1C,CAAA,EAAaa,CAAA,KAA0B;EACnD,OAAOpB,IAAA,CAAIyB,GAAA,CAAIzB,IAAA,CAAImB,GAAA,CAAIZ,CAAA,EAAGa,CAAA,GAAI;;AA9P3BH,GAAA,CAsQEiC,GAAA,GAAM,CAAC3C,CAAA,EAAasC,CAAA,GAAI,MAAgB;EAC7C,OAAO,CAACtC,CAAA,CAAE,KAAKF,IAAA,CAAK8C,GAAA,CAAIN,CAAA,IAAKtC,CAAA,CAAE,KAAKF,IAAA,CAAK+C,GAAA,CAAIP,CAAA,GAAItC,CAAA,CAAE,KAAKF,IAAA,CAAK+C,GAAA,CAAIP,CAAA,IAAKtC,CAAA,CAAE,KAAKF,IAAA,CAAK8C,GAAA,CAAIN,CAAA;;AAvQnF5B,GAAA,CAgREoC,OAAA,GAAU,CAAC9C,CAAA,EAAa+C,CAAA,EAAaT,CAAA,GAAI,MAAgB;EAC9D,IAAIA,CAAA,KAAM,GAAG,OAAOtC,CAAA;EAEpB,MAAMgD,CAAA,GAAIlD,IAAA,CAAK+C,GAAA,CAAIP,CAAA;EACnB,MAAMW,CAAA,GAAInD,IAAA,CAAK8C,GAAA,CAAIN,CAAA;EAEnB,MAAMY,EAAA,GAAKlD,CAAA,CAAE,KAAK+C,CAAA,CAAE;EACpB,MAAMI,EAAA,GAAKnD,CAAA,CAAE,KAAK+C,CAAA,CAAE;EAEpB,MAAMK,EAAA,GAAKF,EAAA,GAAKD,CAAA,GAAIE,EAAA,GAAKH,CAAA;EACzB,MAAMK,EAAA,GAAKH,EAAA,GAAKF,CAAA,GAAIG,EAAA,GAAKF,CAAA;EAEzB,OAAO,CAACG,EAAA,GAAKL,CAAA,CAAE,IAAIM,EAAA,GAAKN,CAAA,CAAE;;AA5RvBrC,GAAA,CAoSE4C,OAAA,GAAU,CAACtD,CAAA,EAAaa,CAAA,KAAyB;EACtD,OAAOb,CAAA,CAAE,OAAOa,CAAA,CAAE,MAAMb,CAAA,CAAE,OAAOa,CAAA,CAAE;;AArShCH,GAAA,CA8SE6C,GAAA,GAAM,CAACvD,CAAA,EAAaa,CAAA,EAAa2C,CAAA,KAAwB;EAC9D,OAAO/D,IAAA,CAAImB,GAAA,CAAIZ,CAAA,EAAGP,IAAA,CAAIyB,GAAA,CAAIzB,IAAA,CAAIsB,GAAA,CAAIF,CAAA,EAAGb,CAAA,GAAIwD,CAAA;;AA/StC9C,GAAA,CA0TE+C,GAAA,GAAM,CAACzD,CAAA,EAAaa,CAAA,EAAa6C,IAAA,EAAcC,EAAA,EAAYX,CAAA,GAAI,MAAgB;EACpF,MAAMQ,CAAA,GAAK,CAAA/D,IAAA,CAAIC,KAAA,CAAMgE,IAAA,EAAMC,EAAA,IAAMD,IAAA,KAASC,EAAA,GAAKD,IAAA;EAC/C,OAAOjE,IAAA,CAAImB,GAAA,CAAInB,IAAA,CAAIyB,GAAA,CAAIlB,CAAA,EAAG,IAAIwD,CAAA,GAAI/D,IAAA,CAAIyB,GAAA,CAAIL,CAAA,EAAGmC,CAAA;;AA5T1CtC,GAAA,CAqUEkD,IAAA,GAAO,CAACC,EAAA,EAAcC,EAAA,EAAcC,EAAA,KAAyB;EAElE,MAAMC,EAAA,GAAKvE,IAAA,CAAIwB,GAAA,CAAI6C,EAAA,EAAID,EAAA;EACvB,MAAMI,EAAA,GAAKxE,IAAA,CAAIwB,GAAA,CAAI6C,EAAA,EAAIC,EAAA;EACvB,OAAOtE,IAAA,CAAI8C,GAAA,CAAIyB,EAAA,EAAIC,EAAA;;AAzUhBvD,GAAA,CAiVE2B,GAAA,GAAOrC,CAAA,IAA0B;EACtC,OAAO,CAACF,IAAA,CAAKuC,GAAA,CAAIrC,CAAA,CAAE,KAAKF,IAAA,CAAKuC,GAAA,CAAIrC,CAAA,CAAE;;AAlVhCU,GAAA,CAqVEwD,OAAA,GAAU,CAAC3D,CAAA,EAAaZ,CAAA,KAAwB;EACrD,MAAMwE,CAAA,GAAI1E,IAAA,CAAIiC,GAAA,CAAInB,CAAA;EAClB,OAAO,CAAEZ,CAAA,GAAIY,CAAA,CAAE,KAAM4D,CAAA,EAAIxE,CAAA,GAAIY,CAAA,CAAE,KAAM4D,CAAA;;AAvVlCzD,GAAA,CAgWE0D,MAAA,GAAS,CAACP,EAAA,EAAcC,EAAA,EAAcC,EAAA,KAAyB;EAIpE,OAAQ,CAAAD,EAAA,CAAG,KAAKD,EAAA,CAAG,OAAOE,EAAA,CAAG,KAAKF,EAAA,CAAG,MAAO,CAAAE,EAAA,CAAG,KAAKF,EAAA,CAAG,OAAOC,EAAA,CAAG,KAAKD,EAAA,CAAG;;AApWtEnD,GAAA,CA6WE2D,SAAA,GAAY,CAACR,EAAA,EAAcC,EAAA,EAAcC,EAAA,KAA0B;EACxE,OAAOtE,IAAA,CAAI2E,MAAA,CAAOP,EAAA,EAAIC,EAAA,EAAIC,EAAA,IAAM;;AA9W7BrD,GAAA,CAsXE4D,OAAA,GAAU,CAAC/D,CAAA,EAAagE,CAAA,GAAI,MAAgB;EACjD,OAAOhE,CAAA,CAAEN,GAAA,CAAKuE,CAAA,IAAM,CAACA,CAAA,CAAEF,OAAA,CAAQC,CAAA;;AAvX5B7D,GAAA,CA8YE+D,8BAAA,GAAiC,CAACzE,CAAA,EAAa0E,CAAA,EAAaC,CAAA,KAA0B;EAC3F,OAAOlF,IAAA,CAAImB,GAAA,CAAIZ,CAAA,EAAGP,IAAA,CAAIyB,GAAA,CAAIwD,CAAA,EAAGjF,IAAA,CAAImC,GAAA,CAAInC,IAAA,CAAIsB,GAAA,CAAI4D,CAAA,EAAG3E,CAAA,GAAI0E,CAAA;;AA/YjDhE,GAAA,CAyZEkE,0BAAA,GAA6B,CAAC5E,CAAA,EAAa0E,CAAA,EAAaC,CAAA,KAAwB;EACrF,OAAOlF,IAAA,CAAIwC,IAAA,CAAK0C,CAAA,EAAGlF,IAAA,CAAIgF,8BAAA,CAA+BzE,CAAA,EAAG0E,CAAA,EAAGC,CAAA;;AA1ZzDjE,GAAA,CAqaEmE,yBAAA,GAA4B,CACjC7E,CAAA,EACAa,CAAA,EACA8D,CAAA,EACAjF,KAAA,GAAQ,SACK;EACb,MAAMgF,CAAA,GAAIjF,IAAA,CAAIoC,GAAA,CAAIpC,IAAA,CAAIsB,GAAA,CAAIF,CAAA,EAAGb,CAAA;EAC7B,MAAM+C,CAAA,GAAItD,IAAA,CAAImB,GAAA,CAAIZ,CAAA,EAAGP,IAAA,CAAIyB,GAAA,CAAIwD,CAAA,EAAGjF,IAAA,CAAImC,GAAA,CAAInC,IAAA,CAAIsB,GAAA,CAAI4D,CAAA,EAAG3E,CAAA,GAAI0E,CAAA;EAEvD,IAAIhF,KAAA,EAAO;IACT,IAAIqD,CAAA,CAAE,KAAKjD,IAAA,CAAKF,GAAA,CAAII,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAK,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE,KAAKb,CAAA,GAAIa,CAAA;IAC1D,IAAIkC,CAAA,CAAE,KAAKjD,IAAA,CAAKD,GAAA,CAAIG,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAK,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE,KAAKb,CAAA,GAAIa,CAAA;IAC1D,IAAIkC,CAAA,CAAE,KAAKjD,IAAA,CAAKF,GAAA,CAAII,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAK,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE,KAAKb,CAAA,GAAIa,CAAA;IAC1D,IAAIkC,CAAA,CAAE,KAAKjD,IAAA,CAAKD,GAAA,CAAIG,CAAA,CAAE,IAAIa,CAAA,CAAE,KAAK,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE,KAAKb,CAAA,GAAIa,CAAA;;EAG5D,OAAOkC,CAAA;;AArbJrC,GAAA,CAgcEoE,qBAAA,GAAwB,CAAC9E,CAAA,EAAaa,CAAA,EAAa8D,CAAA,EAAajF,KAAA,GAAQ,SAAiB;EAC9F,OAAOD,IAAA,CAAIwC,IAAA,CAAK0C,CAAA,EAAGlF,IAAA,CAAIoF,yBAAA,CAA0B7E,CAAA,EAAGa,CAAA,EAAG8D,CAAA,EAAGjF,KAAA;;AAjcvDgB,GAAA,CA2cEqE,KAAA,GAAQ,CAAC/E,CAAA,EAAaa,CAAA,EAAa0D,CAAA,KAAwB;EAChE,IAAI9E,IAAA,CAAI6D,OAAA,CAAQtD,CAAA,EAAGa,CAAA,GAAI,OAAOb,CAAA;EAC9B,OAAOP,IAAA,CAAImB,GAAA,CAAIZ,CAAA,EAAGP,IAAA,CAAIyB,GAAA,CAAIzB,IAAA,CAAIoC,GAAA,CAAIpC,IAAA,CAAIsB,GAAA,CAAIF,CAAA,EAAGb,CAAA,IAAKuE,CAAA;;AA7c/C7D,GAAA,CAsdEsE,YAAA,GAAe,CAAChF,CAAA,EAAaO,CAAA,EAAWgE,CAAA,KAAwB;EACrE,OAAO,CAACzE,IAAA,CAAK8C,GAAA,CAAIrC,CAAA,IAAKgE,CAAA,GAAIvE,CAAA,CAAE,IAAIF,IAAA,CAAK+C,GAAA,CAAItC,CAAA,IAAKgE,CAAA,GAAIvE,CAAA,CAAE;;AAvdjDU,GAAA,CA+dEuE,WAAA,GAAc,CAAC1E,CAAA,EAAaZ,CAAA,GAAI,MAAgB;EACrD,OAAO,CAAC,CAACY,CAAA,CAAE,GAAG0E,WAAA,CAAYtF,CAAA,GAAI,CAACY,CAAA,CAAE,GAAG0E,WAAA,CAAYtF,CAAA;;AAhe7Ce,GAAA,CAyeEwE,aAAA,GAAgB,CAAClF,CAAA,EAAaa,CAAA,EAAasE,KAAA,GAAQ,MAAkB;EAC1E,OAAOC,KAAA,CAAM1B,IAAA,CAAK0B,KAAA,CAAMD,KAAA,GAAQlF,GAAA,CAAI,CAACoF,CAAA,EAAGC,CAAA,KAAM;IAC5C,MAAM9B,CAAA,GAAI8B,CAAA,IAAKH,KAAA,GAAQ;IACvB,MAAMI,CAAA,GAAIzF,IAAA,CAAKF,GAAA,CAAI,GAAG,MAAME,IAAA,CAAKuC,GAAA,CAAI,MAAMmB,CAAA;IAC3C,OAAO,CAAC,GAAG/D,IAAA,CAAI8D,GAAA,CAAIvD,CAAA,EAAGa,CAAA,EAAG2C,CAAA,GAAI+B,CAAA;;;AA7e5B7E,GAAA,CAsfE8E,KAAA,GAAQ,CAACxF,CAAA,EAAaa,CAAA,KAAgB;EAC3C,IAAIb,CAAA,CAAE,OAAOa,CAAA,CAAE,IAAI,OAAO4E,GAAA;EAC1B,OAAQ,CAAAzF,CAAA,CAAE,KAAKa,CAAA,CAAE,OAAOb,CAAA,CAAE,KAAKa,CAAA,CAAE;;AAxf9BH,GAAA,CA8fEb,GAAA,GAAM,IAAI2E,CAAA,KAAkB;EACjC,OAAO,CAAC1E,IAAA,CAAKD,GAAA,CAAI,GAAG2E,CAAA,CAAEvE,GAAA,CAAKM,CAAA,IAAMA,CAAA,CAAE,MAAMT,IAAA,CAAKD,GAAA,CAAI,GAAG2E,CAAA,CAAEvE,GAAA,CAAKM,CAAA,IAAMA,CAAA,CAAE;;AA/fjEG,GAAA,CAqgBEd,GAAA,GAAM,IAAI4E,CAAA,KAAkB;EACjC,OAAO,CAAC1E,IAAA,CAAKD,GAAA,CAAI,GAAG2E,CAAA,CAAEvE,GAAA,CAAKM,CAAA,IAAMA,CAAA,CAAE,MAAMT,IAAA,CAAKD,GAAA,CAAI,GAAG2E,CAAA,CAAEvE,GAAA,CAAKM,CAAA,IAAMA,CAAA,CAAE;;;;ACpgBjE,IAAAmF,MAAA,SAAa;EASlBC,YAAYC,MAAA,GAAqB,IAAI;IARrC,KAAAA,MAAA,GAAqB;IAErB,KAAAC,OAAA,GAAoB;IAEpB,KAAAC,WAAA,GAAc;IAUd,KAAAC,QAAA,GAAYC,KAAA,IAAoB;MAC9B,IAAI,KAAKC,IAAA,EAAM;QACb,MAAMC,MAAA,GAASxF,GAAA,CAAIuB,IAAA,CAAK,KAAKgE,IAAA,EAAMD,KAAA;QACnC,KAAKH,OAAA,CAAQM,IAAA,CAAKD,MAAA;QAClB,KAAKJ,WAAA,IAAeI,MAAA;QACpB,KAAKN,MAAA,CAAOO,IAAA,CAAKH,KAAA;MAAA;MAEnB,KAAKC,IAAA,GAAOD,KAAA;IAAA;IAGd,KAAAI,KAAA,GAAQ,MAAM;MACZ,KAAKR,MAAA,GAAS,KAAKK,IAAA,GAAO,CAAC,KAAKA,IAAA,IAAQ;MACxC,KAAKH,WAAA,GAAc;IAAA;IAGrB,KAAAO,cAAA,GAAkBC,EAAA,IAAyB;MACzC,MAAM;QAAEV;MAAA,IAAW;MACnB,MAAMzB,CAAA,GAAIyB,MAAA,CAAOM,MAAA,GAAS;QACxB3B,CAAA,GAAIzE,IAAA,CAAKyG,KAAA,CAAMD,EAAA;QACfzC,EAAA,GAAK/D,IAAA,CAAKF,GAAA,CAAI2E,CAAA,GAAI,GAAGJ,CAAA;QACrBJ,EAAA,GAAKjE,IAAA,CAAKF,GAAA,CAAIiE,EAAA,GAAK,GAAGM,CAAA;QACtBqC,EAAA,GAAK1G,IAAA,CAAKF,GAAA,CAAImE,EAAA,GAAK,GAAGI,CAAA;QACtBsC,EAAA,GAAK5C,EAAA,GAAK;QACVL,CAAA,GAAI8C,EAAA,GAAK/B,CAAA;MACX,MAAMmC,EAAA,GAAKlD,CAAA,GAAIA,CAAA;QACbmD,GAAA,GAAMD,EAAA,GAAKlD,CAAA;QACXoD,EAAA,GAAK,CAACD,GAAA,GAAM,IAAID,EAAA,GAAKlD,CAAA;QACrBqD,EAAA,GAAK,IAAIF,GAAA,GAAM,IAAID,EAAA,GAAK;QACxBI,EAAA,GAAK,KAAKH,GAAA,GAAM,IAAID,EAAA,GAAKlD,CAAA;QACzBuD,EAAA,GAAKJ,GAAA,GAAMD,EAAA;MACb,OAAO,CACJ,CAAAd,MAAA,CAAOa,EAAA,EAAI,KAAKG,EAAA,GAAKhB,MAAA,CAAO/B,EAAA,EAAI,KAAKgD,EAAA,GAAKjB,MAAA,CAAO7B,EAAA,EAAI,KAAK+C,EAAA,GAAKlB,MAAA,CAAOY,EAAA,EAAI,KAAKO,EAAA,IAAM,GACrF,CAAAnB,MAAA,CAAOa,EAAA,EAAI,KAAKG,EAAA,GAAKhB,MAAA,CAAO/B,EAAA,EAAI,KAAKgD,EAAA,GAAKjB,MAAA,CAAO7B,EAAA,EAAI,KAAK+C,EAAA,GAAKlB,MAAA,CAAOY,EAAA,EAAI,KAAKO,EAAA,IAAM;IAAA;IArCxF,KAAKnB,MAAA,GAASA,MAAA;IACd,KAAKC,OAAA,GAAUD,MAAA,CAAO3F,GAAA,CAAI,CAAC+F,KAAA,EAAOV,CAAA,EAAG0B,GAAA,KAAS1B,CAAA,KAAM,IAAI,IAAI5E,GAAA,CAAIuB,IAAA,CAAK+D,KAAA,EAAOgB,GAAA,CAAI1B,CAAA,GAAI;IACpF,KAAKQ,WAAA,GAAc,KAAKD,OAAA,CAAQoB,MAAA,CAAO,CAACC,GAAA,EAAKC,GAAA,KAAQD,GAAA,GAAMC,GAAA,EAAK;EAAA;AAAA;;;ACF7D,IAAAC,cAAA,SAAoB;EAUzBzB,YAAY0B,EAAA,EAA+B;IAT3C,KAAAC,KAAA,GAAwB;IACxB,KAAAC,KAAA,GAAqB;IACrB,KAAAC,SAAA,GAAYC,WAAA,CAAYC,GAAA;IACxB,KAAAC,aAAA,GAAgB;IAChB,KAAAC,SAAA,GAAiB;IAEjB,KAAAC,MAAA,GAAS,IAAInC,MAAA;IAOb,KAAAK,QAAA,GAAYC,KAAA,IAAoB;MAC9B8B,YAAA,CAAa,KAAKF,SAAA;MAClB,MAAMF,GAAA,GAAMD,WAAA,CAAYC,GAAA;MACxB,MAAMK,QAAA,GAAWjI,IAAA,CAAKF,GAAA,CAAI8H,GAAA,GAAM,KAAKF,SAAA,EAAWJ,cAAA,CAAcY,YAAA;MAC9D,IAAI,CAAC,KAAKC,SAAA,EAAW;QACnB,KAAKJ,MAAA,CAAOzB,KAAA;QACZ,KAAK6B,SAAA,GAAYjC,KAAA;QACjB,KAAK6B,MAAA,CAAO9B,QAAA,CAASC,KAAA;QACrB,KAAKqB,EAAA,CAAGrB,KAAA;QACR,KAAKsB,KAAA,GAAQ;QACb;MAAA;MAEF,IAAI,KAAKA,KAAA,KAAU,WAAW;QAC5B,IAAI5G,GAAA,CAAIuB,IAAA,CAAK,KAAKgG,SAAA,EAAWjC,KAAA,IAAS,GAAG;UACvC,KAAKqB,EAAA,CAAGrB,KAAA;UACR;QAAA;QAEF,KAAK6B,MAAA,CAAOzB,KAAA;QACZ,KAAKyB,MAAA,CAAO9B,QAAA,CAAS,KAAKkC,SAAA;QAC1B,KAAKJ,MAAA,CAAO9B,QAAA,CAAS,KAAKkC,SAAA;QAC1B,KAAKJ,MAAA,CAAO9B,QAAA,CAASC,KAAA;QACrB,KAAKsB,KAAA,GAAQ;MAAA,OACR;QACL,KAAKO,MAAA,CAAO9B,QAAA,CAASC,KAAA;MAAA;MAEvB,IAAI+B,QAAA,GAAW,IAAI;QACjB,KAAKE,SAAA,GAAYjC,KAAA;QACjB,KAAKwB,SAAA,GAAYE,GAAA;QACjB,KAAKL,EAAA,CAAGrB,KAAA;QACR;MAAA;MAEF,MAAMkC,SAAA,GAAuB;QAC3BC,KAAA,EAAO,KAAKN,MAAA,CAAOjC,MAAA,CAAOM,MAAA,GAAS;QACnCxC,IAAA,EAAM,KAAKuE,SAAA;QACXtE,EAAA,EAAIqC,KAAA;QACJ+B;MAAA;MAEF,KAAKE,SAAA,GAAYjC,KAAA;MACjB,KAAKwB,SAAA,GAAYE,GAAA;MACjB,QAAQ,KAAKJ,KAAA;QAAA,KACN;UAAQ;YACX,KAAKA,KAAA,GAAQ;YACb,KAAKc,WAAA,CAAYF,SAAA;YACjB;UAAA;QAAA,KAEG;UAAa;YAChB,KAAKX,KAAA,CAAMpB,IAAA,CAAK+B,SAAA;YAChB;UAAA;MAAA;IAAA;IAKN,KAAAE,WAAA,GAAeF,SAAA,IAAyB;MACtC,MAAMC,KAAA,GAAQV,WAAA,CAAYC,GAAA;MAC1B,MAAMW,IAAA,GAAOA,CAAA,KAAM;QACjB,MAAM7E,CAAA,GAAK,CAAAiE,WAAA,CAAYC,GAAA,KAAQS,KAAA,IAASD,SAAA,CAAUH,QAAA;QAClD,IAAIvE,CAAA,IAAK,KAAK,KAAKqE,MAAA,CAAOjC,MAAA,CAAOM,MAAA,GAAS,GAAG;UAC3C,IAAI;YACF,KAAKmB,EAAA,CAAG,KAAKQ,MAAA,CAAOxB,cAAA,CAAe7C,CAAA,GAAI0E,SAAA,CAAUC,KAAA;UAAA,SAC1CG,CAAA,EAAP;YACAC,OAAA,CAAQC,IAAA,CAAKF,CAAA;UAAA;UAEf,KAAKX,aAAA,GAAgBc,qBAAA,CAAsBJ,IAAA;UAC3C;QAAA;QAEF,MAAMK,IAAA,GAAO,KAAKnB,KAAA,CAAMoB,KAAA;QACxB,IAAID,IAAA,EAAM;UACR,KAAKpB,KAAA,GAAQ;UACb,KAAKc,WAAA,CAAYM,IAAA;QAAA,OACZ;UACL,KAAKpB,KAAA,GAAQ;UACb,KAAKM,SAAA,GAAYgB,UAAA,CAAW,MAAM;YAChC,KAAKtB,KAAA,GAAQ;UAAA,GACZF,cAAA,CAAcY,YAAA;QAAA;MAAA;MAGrBK,IAAA;IAAA;IAKF,KAAAQ,OAAA,GAAU,MAAM;MACdf,YAAA,CAAa,KAAKF,SAAA;IAAA;IArFlB,KAAKP,EAAA,GAAKA,EAAA;EAAA;AAAA;AAXP,IAAAyB,aAAA,GAAA1B,cAAA;AA6FE0B,aA7FF,CA6FEd,YAAA,GAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}